<document xmlns="http://cnx.rice.edu/cnxml" xmlns:m="http://www.w3.org/1998/Math/MathML" xmlns:md="http://cnx.rice.edu/mdml">
  <title>Sparsity in Redundant Dictionaries</title>
  <metadata>
  <md:content-id>m23073</md:content-id><md:title>Sparsity in Redundant Dictionaries</md:title>
  <md:abstract>This collection comprises Chapter 1 of the book
    A Wavelet Tour of Signal Processing, The Sparse Way
    (third edition, 2009) by Stéphane Mallat.  The book's
    website at Academic Press is
http://www.elsevier.com/wps/find/bookdescription.cws_home/714561/description#description
    The book's complementary materials are available at
http://wavelet-tour.com</md:abstract>
  <md:uuid>7f9d0898-17ff-4424-a5f5-eb4cf5efbf51</md:uuid>
</metadata>

<content>

      <para id="id2258269">In natural languages, large dictionaries are needed to refine ideas
with short sentences, and they evolve with usage.
Eskimos have eight different words
to describe <emphasis effect="italics">snow quality</emphasis>, whereas a single word is typically sufficient in a
Parisian dictionary.Similarly, large signal dictionaries of vectors are needed to construct
sparse representations of complex signals. However,
computing and optimizing a signal approximation by choosing
the best <emphasis effect="italics">M</emphasis> dictionary vectors is much more difficult.</para>
      <figure id="uid1">
        <media id="uid1_media" alt="">
          <image mime-type="image/png" src="../../media/newfig8.png" id="uid1_onlineimage" width="432"><!-- NOTE: attribute width changes image size online (pixels). original width is 432. --></image>
          <image for="pdf" mime-type="application/postscript" src="../../media/newfig8-d2f3.eps" id="uid1_printimage"/>
        </media>
        <caption>A local cosine basis divides the time axis
with smooth windows <m:math overflow="scroll"><m:mrow><m:msub><m:mi>g</m:mi><m:mi>p</m:mi></m:msub><m:mrow><m:mo>(</m:mo><m:mi>t</m:mi><m:mo>)</m:mo></m:mrow></m:mrow></m:math> and
translates these windows into frequency.</caption>
      </figure>
      <section id="uid2">
        <title>Frame Analysis and Synthesis</title>
        <para id="id2258982">Suppose that a sparse family of vectors <m:math overflow="scroll"><m:msub><m:mrow><m:mo>{</m:mo><m:msub><m:mi>φ</m:mi><m:mi>p</m:mi></m:msub><m:mo>}</m:mo></m:mrow><m:mrow><m:mi>p</m:mi><m:mo>∈</m:mo><m:mi>Λ</m:mi></m:mrow></m:msub></m:math> has
been selected to approximate a signal <m:math overflow="scroll"><m:mrow><m:mspace width="0.166667em"/><m:mi>f</m:mi></m:mrow></m:math>.
An approximation can be recovered
as an orthogonal projection in
the space <emphasis effect="italics">V<sub>λ</sub></emphasis> generated by these vectors.
We then face one of the following twoproblems.</para>
        <list id="id2259048" display="block" list-type="enumerated">
          <item id="uid3">In a <emphasis effect="italics">dual-synthesis</emphasis> problem, the orthogonal projection <m:math overflow="scroll"><m:mrow><m:mspace width="0.166667em"/><m:msub><m:mi>f</m:mi><m:mi>λ</m:mi></m:msub></m:mrow></m:math>
of <m:math overflow="scroll"><m:mrow><m:mspace width="0.166667em"/><m:mi>f</m:mi></m:mrow></m:math> in <emphasis effect="italics">V<sub>λ</sub></emphasis> must be computed from dictionary coefficients,
<m:math overflow="scroll"><m:msub><m:mrow><m:mo>{</m:mo><m:mo>〈</m:mo><m:mspace width="0.166667em"/><m:mi>f</m:mi><m:mo>,</m:mo><m:msub><m:mi>φ</m:mi><m:mi>p</m:mi></m:msub><m:mo>〉</m:mo><m:mo>}</m:mo></m:mrow><m:mrow><m:mi>p</m:mi><m:mo>∈</m:mo><m:mi>λ</m:mi></m:mrow></m:msub></m:math>, provided by an analysis operator.
 This is the case when a signal transform <m:math overflow="scroll"><m:msub><m:mrow><m:mo>{</m:mo><m:mo>〈</m:mo><m:mspace width="0.166667em"/><m:mi>f</m:mi><m:mo>,</m:mo><m:msub><m:mi>φ</m:mi><m:mi>p</m:mi></m:msub><m:mo>〉</m:mo><m:mo>}</m:mo></m:mrow><m:mrow><m:mi>p</m:mi><m:mo>∈</m:mo><m:mi>Γ</m:mi></m:mrow></m:msub></m:math>
is calculated in some large dictionary and a subset of inner products
are selected. Such inner products may correspond to
coefficients above a threshold or local maxima values.
</item>
          <item id="uid4">In a <emphasis effect="italics">dual-analysis</emphasis> problem, the decomposition
coefficients of <m:math overflow="scroll"><m:mrow><m:mspace width="0.166667em"/><m:msub><m:mi>f</m:mi><m:mi>λ</m:mi></m:msub></m:mrow></m:math> must be computed
on a family of selected vectors <m:math overflow="scroll"><m:msub><m:mrow><m:mo>{</m:mo><m:msub><m:mi>φ</m:mi><m:mi>p</m:mi></m:msub><m:mo>}</m:mo></m:mrow><m:mrow><m:mi>p</m:mi><m:mo>∈</m:mo><m:mi>Λ</m:mi></m:mrow></m:msub></m:math>. This
problem appears when sparse representation algorithms
select vectors as opposed to inner products.
This is the case for
pursuit algorithms, which compute
approximation supports in highly redundant dictionaries.
</item>
        </list>
        <para id="id2259290">The frame theory gives energy equivalence conditions
to solve both problems with stable operators.
A family <m:math overflow="scroll"><m:msub><m:mrow><m:mo>{</m:mo><m:msub><m:mi>φ</m:mi><m:mi>p</m:mi></m:msub><m:mo>}</m:mo></m:mrow><m:mrow><m:mi>p</m:mi><m:mo>∈</m:mo><m:mi>Λ</m:mi></m:mrow></m:msub></m:math> is a frame of the space <emphasis effect="bold">V</emphasis> it generates
if there exists <m:math overflow="scroll"><m:mrow><m:mi>B</m:mi><m:mo>≥</m:mo><m:mi>A</m:mi><m:mo>&gt;</m:mo><m:mn>0</m:mn></m:mrow></m:math> such that</para>
        <equation id="id2259356">
          <m:math overflow="scroll" mode="display">
            <m:mrow>
              <m:mo>∀</m:mo>
              <m:mi>h</m:mi>
              <m:mo>∈</m:mo>
              <m:msup>
                <m:mrow>
                  <m:mi mathvariant="bold">V</m:mi>
                  <m:mo>,</m:mo>
                  <m:mspace width="5.0pt"/>
                  <m:mi>A</m:mi>
                  <m:mo>∥</m:mo>
                  <m:mi>h</m:mi>
                  <m:mo>∥</m:mo>
                </m:mrow>
                <m:mn>2</m:mn>
              </m:msup>
              <m:mspace width="0.166667em"/>
              <m:mo>≤</m:mo>
              <m:mspace width="0.166667em"/>
              <m:munder>
                <m:mo>∑</m:mo>
                <m:mrow>
                  <m:mi>m</m:mi>
                  <m:mo>∈</m:mo>
                  <m:mi>λ</m:mi>
                </m:mrow>
              </m:munder>
              <m:mrow>
                <m:mo>|</m:mo>
                <m:mo>〈</m:mo>
                <m:mi>h</m:mi>
                <m:mo>,</m:mo>
              </m:mrow>
              <m:msub>
                <m:mi>φ</m:mi>
                <m:mi>p</m:mi>
              </m:msub>
              <m:msup>
                <m:mrow>
                  <m:mo>〉</m:mo>
                  <m:mo>|</m:mo>
                </m:mrow>
                <m:mn>2</m:mn>
              </m:msup>
              <m:mspace width="0.166667em"/>
              <m:mo>≤</m:mo>
              <m:mspace width="0.166667em"/>
              <m:mi>B</m:mi>
              <m:msup>
                <m:mrow>
                  <m:mo>∥</m:mo>
                  <m:mi>h</m:mi>
                  <m:mo>∥</m:mo>
                </m:mrow>
                <m:mn>2</m:mn>
              </m:msup>
              <m:mo>.</m:mo>
            </m:mrow>
          </m:math>
        </equation>
        <para id="id2259710">The representation is stable since
any perturbation of frame coefficients
implies a modification of similar magnitude
on <emphasis effect="italics">h</emphasis>. Chapter 5
proves that the existence of a dual frame
<m:math overflow="scroll"><m:msub><m:mrow><m:mo>{</m:mo><m:msub><m:mover accent="true"><m:mi>φ</m:mi><m:mo>˜</m:mo></m:mover><m:mi>p</m:mi></m:msub><m:mo>}</m:mo></m:mrow><m:mrow><m:mi>p</m:mi><m:mo>∈</m:mo><m:mi>Λ</m:mi></m:mrow></m:msub></m:math> that solves both the
dual-synthesis and dual-analysisproblems:</para>
        <equation id="uid6">
          <m:math overflow="scroll" mode="display">
            <m:mtable displaystyle="true">
              <m:mtr>
                <m:mtd columnalign="right">
                  <m:mrow>
                    <m:msub>
                      <m:mi>f</m:mi>
                      <m:mi>λ</m:mi>
                    </m:msub>
                    <m:mo>=</m:mo>
                    <m:munder>
                      <m:mo>∑</m:mo>
                      <m:mrow>
                        <m:mi>p</m:mi>
                        <m:mo>∈</m:mo>
                        <m:mi>λ</m:mi>
                      </m:mrow>
                    </m:munder>
                    <m:mo>〈</m:mo>
                    <m:mspace width="0.166667em"/>
                    <m:mi>f</m:mi>
                    <m:mo>,</m:mo>
                    <m:msub>
                      <m:mi>φ</m:mi>
                      <m:mi>p</m:mi>
                    </m:msub>
                    <m:mo>〉</m:mo>
                    <m:mspace width="0.166667em"/>
                    <m:msub>
                      <m:mover accent="true">
                        <m:mi>φ</m:mi>
                        <m:mo>˜</m:mo>
                      </m:mover>
                      <m:mi>p</m:mi>
                    </m:msub>
                    <m:mo>=</m:mo>
                    <m:munder>
                      <m:mo>∑</m:mo>
                      <m:mrow>
                        <m:mi>p</m:mi>
                        <m:mo>∈</m:mo>
                        <m:mi>λ</m:mi>
                      </m:mrow>
                    </m:munder>
                    <m:mo>〈</m:mo>
                    <m:mspace width="0.166667em"/>
                    <m:mi>f</m:mi>
                    <m:mo>,</m:mo>
                    <m:msub>
                      <m:mover accent="true">
                        <m:mi>φ</m:mi>
                        <m:mo>˜</m:mo>
                      </m:mover>
                      <m:mi>p</m:mi>
                    </m:msub>
                    <m:mo>〉</m:mo>
                    <m:mspace width="0.166667em"/>
                    <m:msub>
                      <m:mi>φ</m:mi>
                      <m:mi>p</m:mi>
                    </m:msub>
                    <m:mo>.</m:mo>
                  </m:mrow>
                </m:mtd>
              </m:mtr>
            </m:mtable>
          </m:math>
        </equation>
        <para id="id2259895"> 
Algorithms are provided to calculate these decompositions.
The dual frame is also stable:</para>
        <equation id="id2259908">
          <m:math overflow="scroll" mode="display">
            <m:mrow>
              <m:mo>∀</m:mo>
              <m:mi>f</m:mi>
              <m:mspace width="0.166667em"/>
              <m:mo>∈</m:mo>
              <m:mspace width="0.166667em"/>
              <m:mi mathvariant="bold">V</m:mi>
              <m:mo>,</m:mo>
              <m:mspace width="5.0pt"/>
              <m:msup>
                <m:mi>B</m:mi>
                <m:mrow>
                  <m:mo>-</m:mo>
                  <m:mn>1</m:mn>
                </m:mrow>
              </m:msup>
              <m:msup>
                <m:mrow>
                  <m:mo>∥</m:mo>
                  <m:mspace width="0.166667em"/>
                  <m:mi>f</m:mi>
                  <m:mo>∥</m:mo>
                </m:mrow>
                <m:mn>2</m:mn>
              </m:msup>
              <m:mo>≤</m:mo>
              <m:munder>
                <m:mo>∑</m:mo>
                <m:mrow>
                  <m:mi>m</m:mi>
                  <m:mo>∈</m:mo>
                  <m:mi>γ</m:mi>
                </m:mrow>
              </m:munder>
              <m:mrow>
                <m:mo>|</m:mo>
                <m:mo>〈</m:mo>
                <m:mspace width="0.166667em"/>
                <m:mi>f</m:mi>
                <m:mo>,</m:mo>
              </m:mrow>
              <m:msub>
                <m:mover accent="true">
                  <m:mi>φ</m:mi>
                  <m:mo>˜</m:mo>
                </m:mover>
                <m:mi>p</m:mi>
              </m:msub>
              <m:msup>
                <m:mrow>
                  <m:mo>〉</m:mo>
                  <m:mo>|</m:mo>
                </m:mrow>
                <m:mn>2</m:mn>
              </m:msup>
              <m:mspace width="0.166667em"/>
              <m:mo>≤</m:mo>
              <m:mspace width="0.166667em"/>
              <m:msup>
                <m:mi>B</m:mi>
                <m:mrow>
                  <m:mo>-</m:mo>
                  <m:mn>1</m:mn>
                </m:mrow>
              </m:msup>
              <m:msup>
                <m:mrow>
                  <m:mo>∥</m:mo>
                  <m:mspace width="0.166667em"/>
                  <m:mi>f</m:mi>
                  <m:mo>∥</m:mo>
                </m:mrow>
                <m:mn>2</m:mn>
              </m:msup>
              <m:mo>.</m:mo>
            </m:mrow>
          </m:math>
        </equation>
        <para id="id2260060">The frame bounds <emphasis effect="italics">A</emphasis> and <emphasis effect="italics">B</emphasis> are redundancy factors.
If the vectors <m:math overflow="scroll"><m:msub><m:mrow><m:mo>{</m:mo><m:msub><m:mi>φ</m:mi><m:mi>p</m:mi></m:msub><m:mo>}</m:mo></m:mrow><m:mrow><m:mi>p</m:mi><m:mo>∈</m:mo><m:mi>Γ</m:mi></m:mrow></m:msub></m:math> are normalized and
linearly independent, then <m:math overflow="scroll"><m:mrow><m:mi>A</m:mi><m:mo>≤</m:mo><m:mn>1</m:mn><m:mo>≤</m:mo><m:mi>B</m:mi></m:mrow></m:math>. Such a dictionary
is called a <emphasis effect="italics">Riesz basis</emphasis> of <emphasis effect="bold">V</emphasis> and the dual frame is biorthogonal:</para>
        <equation id="id2260147">
          <m:math overflow="scroll" mode="display">
            <m:mrow>
              <m:mo>∀</m:mo>
              <m:mrow>
                <m:mo>(</m:mo>
                <m:mspace width="0.166667em"/>
                <m:mi>p</m:mi>
                <m:mo>,</m:mo>
                <m:mi>p</m:mi>
                <m:mo>'</m:mo>
                <m:mo>)</m:mo>
              </m:mrow>
              <m:mo>∈</m:mo>
              <m:msup>
                <m:mrow>
                  <m:mi>λ</m:mi>
                </m:mrow>
                <m:mn>2</m:mn>
              </m:msup>
              <m:mo>,</m:mo>
              <m:mspace width="3.33333pt"/>
              <m:mo>〈</m:mo>
              <m:msub>
                <m:mi>φ</m:mi>
                <m:mi>p</m:mi>
              </m:msub>
              <m:mo>,</m:mo>
              <m:msub>
                <m:mover accent="true">
                  <m:mi>φ</m:mi>
                  <m:mo>˜</m:mo>
                </m:mover>
                <m:mrow>
                  <m:mi>p</m:mi>
                  <m:mo>'</m:mo>
                </m:mrow>
              </m:msub>
              <m:mo>〉</m:mo>
              <m:mo>=</m:mo>
              <m:mi>δ</m:mi>
              <m:mrow>
                <m:mo>[</m:mo>
                <m:mspace width="0.166667em"/>
                <m:mi>p</m:mi>
                <m:mo>-</m:mo>
                <m:mi>p</m:mi>
                <m:mo>'</m:mo>
                <m:mo>]</m:mo>
              </m:mrow>
              <m:mo>.</m:mo>
            </m:mrow>
          </m:math>
        </equation>
        <para id="id2260246">When the basis is orthonormal, then both bases are equal.
Analysis and synthesis problems are then identical.</para>
        <para id="id2260253">The frame theory is also used to construct redundant dictionaries
that define complete, stable, and redundant signal representations,
where <emphasis effect="bold">V</emphasis> is then the whole signal space. The frame bounds
measure the redundancy of such dictionaries.
Chapter 5 studies the construction of
windowed Fourier and wavelet frame dictionaries by sampling
their time, frequency, and scaling parameters,
while controlling frame bounds.
In two dimensions, directional wavelet frames include wavelets
sensitive to directional image structures such as textures or edges.</para>
        <para id="id2260283">To improve the sparsity of images having edges along regular geometric
curves, Candès and Donoho (CandesD:99)
introduced curvelet frames, with elongated waveforms having
different directions, positions, and scales.
Images with piecewise regular edges have representations that are
asymptotically more sparse by thresholding curvelet
coefficients than wavelet coefficients.</para>
      </section>
      <section id="uid9">
        <title>Ideal Dictionary Approximations</title>
        <para id="id2258802">In a redundant dictionary
<m:math overflow="scroll"><m:mrow><m:mi mathvariant="script">D</m:mi><m:mo>=</m:mo><m:msub><m:mrow><m:mo>{</m:mo><m:msub><m:mi>φ</m:mi><m:mi>p</m:mi></m:msub><m:mo>}</m:mo></m:mrow><m:mrow><m:mi>p</m:mi><m:mo>∈</m:mo><m:mi>γ</m:mi></m:mrow></m:msub></m:mrow></m:math>,  we would like to find the best
approximation support <emphasis effect="italics">λ</emphasis> with
<m:math overflow="scroll"><m:mrow><m:mi>M</m:mi><m:mo>=</m:mo><m:mo>|</m:mo><m:mi>λ</m:mi><m:mo>|</m:mo></m:mrow></m:math> vectors, which minimize the error <m:math overflow="scroll"><m:mrow><m:mrow><m:mo>∥</m:mo><m:mspace width="0.166667em"/><m:mi>f</m:mi><m:mo>-</m:mo></m:mrow><m:msub><m:mi>f</m:mi><m:mi>λ</m:mi></m:msub><m:msup><m:mrow><m:mo>∥</m:mo></m:mrow><m:mn>2</m:mn></m:msup></m:mrow></m:math>. Chapter 12
proves that
it is equivalent to find <emphasis effect="italics">λ<sub>T</sub></emphasis>, which minimizes the
corresponding approximation Lagrangian</para>
        <equation id="uid10">
          <m:math overflow="scroll" mode="display">
            <m:mtable displaystyle="true">
              <m:mtr>
                <m:mtd columnalign="right">
                  <m:mrow>
                    <m:msub>
                      <m:mi mathvariant="script">L</m:mi>
                      <m:mn>0</m:mn>
                    </m:msub>
                    <m:mrow>
                      <m:mrow>
                        <m:mo>(</m:mo>
                        <m:mi>T</m:mi>
                        <m:mo>,</m:mo>
                        <m:mspace width="0.166667em"/>
                        <m:mi>f</m:mi>
                        <m:mo>,</m:mo>
                        <m:mi>λ</m:mi>
                        <m:mo>)</m:mo>
                      </m:mrow>
                      <m:mo>=</m:mo>
                      <m:mo>∥</m:mo>
                      <m:mspace width="0.166667em"/>
                      <m:mi>f</m:mi>
                      <m:mo>-</m:mo>
                    </m:mrow>
                    <m:msub>
                      <m:mi>f</m:mi>
                      <m:mi>λ</m:mi>
                    </m:msub>
                    <m:msup>
                      <m:mrow>
                        <m:mo>∥</m:mo>
                      </m:mrow>
                      <m:mn>2</m:mn>
                    </m:msup>
                    <m:mo>+</m:mo>
                    <m:msup>
                      <m:mi>T</m:mi>
                      <m:mn>2</m:mn>
                    </m:msup>
                    <m:mrow>
                      <m:mo>|</m:mo>
                      <m:mi>λ</m:mi>
                      <m:mo>|</m:mo>
                    </m:mrow>
                    <m:mo>,</m:mo>
                  </m:mrow>
                </m:mtd>
              </m:mtr>
            </m:mtable>
          </m:math>
        </equation>
        <para id="id2260663">
for some multiplier <emphasis effect="italics">T</emphasis>.

</para>
        <para id="id2260688">Compression and denoising are two applications of redundant dictionary
approximations. When compressing signals by quantizing
dictionary coefficients,
the distortion rate varies, like the
Lagrangian <link target-id="uid10"/>, with a multiplier
<emphasis effect="italics">T</emphasis> that depends on the quantization step. Optimizing the coder
is thus equivalent to minimizing this approximation Lagrangian.
For sparse representations, most of the bits are devoted
to coding the geometry of the sparse approximation set <emphasis effect="italics">λ<sub>T</sub></emphasis> in <emphasis effect="italics">γ</emphasis>.</para>
        <para id="id2260735">Estimators reducing noise from observations <m:math overflow="scroll"><m:mrow><m:mi>X</m:mi><m:mo>=</m:mo><m:mi>f</m:mi><m:mo>+</m:mo><m:mi>W</m:mi></m:mrow></m:math> are also
optimized by finding a best orthogonal projector over a set of
dictionary vectors.
The <emphasis effect="italics">model selection</emphasis> theory of Barron, Birgé, and Massart
(massart-birge-barron) proves that finding <m:math overflow="scroll"><m:msub><m:mover accent="true"><m:mi>λ</m:mi><m:mo>˜</m:mo></m:mover><m:mi>T</m:mi></m:msub></m:math>,
which minimizes this same Lagrangian
<m:math overflow="scroll"><m:mrow><m:msub><m:mi mathvariant="script">L</m:mi><m:mn>0</m:mn></m:msub><m:mrow><m:mo>(</m:mo><m:mi>T</m:mi><m:mo>,</m:mo><m:mi>X</m:mi><m:mo>,</m:mo><m:mi>λ</m:mi><m:mo>)</m:mo></m:mrow></m:mrow></m:math>,
defines an estimator that has a risk on the same order as
the minimum approximation error <m:math overflow="scroll"><m:mrow><m:mrow><m:mo>∥</m:mo><m:mspace width="0.166667em"/><m:mi>f</m:mi><m:mo>-</m:mo></m:mrow><m:msub><m:mi>f</m:mi><m:msub><m:mi>Λ</m:mi><m:mi>T</m:mi></m:msub></m:msub><m:msup><m:mrow><m:mo>∥</m:mo></m:mrow><m:mn>2</m:mn></m:msup></m:mrow></m:math> up to a logarithmic
factor.  This is similar to the optimality result obtained for
thresholding estimators in an orthonormal basis.</para>
        <para id="id2260866">The bad news is that minimizing the approximation Lagrangian <emphasis effect="italics">L<sub>0</sub></emphasis>
is an NP-hard problem and is therefore computationally intractable.
It is necessary therefore to find algorithms that are sufficiently fast
to compute suboptimal, but “good enough,” solutions.</para>
        <section id="uid13">
          <title>Dictionaries of Orthonormal Bases</title>
          <para id="id2260902">To reduce the complexity of optimal approximations,
the search can be reduced to subfamilies of
orthogonal dictionary vectors.
In a dictionary of orthonormal bases, any family of orthogonal dictionary
vectors can be complemented to form an orthogonal basis
<m:math overflow="scroll"><m:mi mathvariant="script">B</m:mi></m:math> included in <m:math overflow="scroll"><m:mi mathvariant="script">D</m:mi></m:math>. As a result, the best
approximation of <m:math overflow="scroll"><m:mrow><m:mspace width="0.166667em"/><m:mi>f</m:mi></m:mrow></m:math> from orthogonal vectors in <m:math overflow="scroll"><m:mi mathvariant="script">B</m:mi></m:math> is obtained
by thresholding the coefficients of <m:math overflow="scroll"><m:mrow><m:mspace width="0.166667em"/><m:mi>f</m:mi></m:mrow></m:math> in
a “best basis” in <m:math overflow="scroll"><m:mi mathvariant="script">D</m:mi></m:math>.</para>
          <para id="id2260983">For tree dictionaries of orthonormal bases obtained by
a recursive split of orthogonal vector spaces, the fast, dynamic programming
algorithm of Coifman and Wickerhauser (CoifmanMW:92)
finds such a best basis with <m:math overflow="scroll"><m:mrow><m:mi>O</m:mi><m:mo>(</m:mo><m:mi>P</m:mi><m:mo>)</m:mo></m:mrow></m:math> operations, where <emphasis effect="italics">P</emphasis> is the
dictionary size.</para>
          <para id="id2261016">Wavelet packet and local cosine bases are examples of
tree dictionaries of time-frequency
orthonormal bases of size <m:math overflow="scroll"><m:mrow><m:mi>P</m:mi><m:mo>=</m:mo><m:mi>N</m:mi><m:msub><m:mo form="prefix">log</m:mo><m:mn>2</m:mn></m:msub><m:mi>N</m:mi></m:mrow></m:math>.
A best basis is a
time-frequency tiling that is the best match to the
signal time-frequency structures.</para>
          <para id="id2261050">To approximate geometrically regular edges,
wavelets are not as efficient
as curvelets, but wavelets provide more sparse representations of
singularities that are not distributed along geometrically regular curves.
Bandlet dictionaries,
introduced by Le Pennec,
Mallat, and Peyré (bandelets-siam, bandlets-peyre),
are dictionaries of orthonormal bases that can adapt
to the variability of images' geometric regularity.
Minimax optimal asymptotic rates are derived for compression and denoising.</para>
        </section>
      </section>
      <section id="uid14">
        <title>Pursuit in Dictionaries</title>
        <para id="id2261079">Approximating signals only from orthogonal vectors
brings rigidity that limits the ability to
optimize the representation.
Pursuit algorithms remove this constraint with flexible procedures
that search for sparse, although not necessarily optimal, dictionary
approximations. Such approximations are computed by optimizing
the choice of dictionary vectors <m:math overflow="scroll"><m:msub><m:mrow><m:mo>{</m:mo><m:msub><m:mi>φ</m:mi><m:mi>p</m:mi></m:msub><m:mo>}</m:mo></m:mrow><m:mrow><m:mi>p</m:mi><m:mo>∈</m:mo><m:mi>Λ</m:mi></m:mrow></m:msub></m:math>.</para>
        <section id="uid15">
          <title>Matching Pursuit</title>
          <para id="id2261135">Matching pursuit algorithms introduced by Mallat and Zhang (MallatZ:93)
are greedy algorithms that optimize approximations by selecting
dictionary vectors one by one.
The vector in <m:math overflow="scroll"><m:mrow><m:msub><m:mi>φ</m:mi><m:msub><m:mi>p</m:mi><m:mn>0</m:mn></m:msub></m:msub><m:mo>∈</m:mo><m:mi mathvariant="script">D</m:mi></m:mrow></m:math> that best approximates a signal <m:math overflow="scroll"><m:mrow><m:mspace width="0.166667em"/><m:mi>f</m:mi></m:mrow></m:math> is</para>
          
          <equation id="eip-427"><m:math>
<m:msub>
<m:mi>Φ</m:mi>
<m:mrow>
<m:msub>
<m:mi>p</m:mi>
<m:mn>0</m:mn>
</m:msub>
</m:mrow>
</m:msub>
<m:mo>=</m:mo>
<m:munder>
<m:mrow>
<m:mtext>argmax</m:mtext>
</m:mrow>
<m:mrow>
<m:mi>p</m:mi>
<m:mi>є</m:mi>
<m:mi>Ґ</m:mi>
</m:mrow>
</m:munder>
<m:mo>|</m:mo>
<m:mo>〈</m:mo>
<m:mi>f</m:mi>
<m:mo>,</m:mo>
<m:mi>Φ</m:mi>
<m:mi>p</m:mi>
<m:mo>〉</m:mo>
<m:mo>|</m:mo>
</m:math>
</equation><para id="id2261187">and the residual approximation error is</para>
          <equation id="id2261190">
            <m:math overflow="scroll" mode="display">
              <m:mrow>
                <m:mi>R</m:mi>
                <m:mi>f</m:mi>
                <m:mspace width="0.166667em"/>
                <m:mo>=</m:mo>
                <m:mspace width="0.166667em"/>
                <m:mi>f</m:mi>
                <m:mo>-</m:mo>
                <m:mo>〈</m:mo>
                <m:mspace width="0.166667em"/>
                <m:mi>f</m:mi>
                <m:mo>,</m:mo>
                <m:msub>
                  <m:mi>φ</m:mi>
                  <m:msub>
                    <m:mi>p</m:mi>
                    <m:mn>0</m:mn>
                  </m:msub>
                </m:msub>
                <m:mo>〉</m:mo>
                <m:mspace width="0.166667em"/>
                <m:msub>
                  <m:mi>φ</m:mi>
                  <m:msub>
                    <m:mi>p</m:mi>
                    <m:mn>0</m:mn>
                  </m:msub>
                </m:msub>
                <m:mo>.</m:mo>
              </m:mrow>
            </m:math>
          </equation>
          <para id="id2261262">A matching pursuit further approximates the residue
<m:math overflow="scroll"><m:mrow><m:mi>R</m:mi><m:mi>f</m:mi></m:mrow></m:math> by selecting another best vector <m:math overflow="scroll"><m:msub><m:mi>φ</m:mi><m:msub><m:mi>p</m:mi><m:mn>1</m:mn></m:msub></m:msub></m:math> from the dictionary and
continues this process over next-order residues <m:math overflow="scroll"><m:mrow><m:msup><m:mi>R</m:mi><m:mi>m</m:mi></m:msup><m:mi>f</m:mi></m:mrow></m:math>,
which produces a signal decomposition:</para>
          <equation id="id2261318"><m:math overflow="scroll" mode="display">
              <m:mrow>
                <m:mi>f</m:mi>
                <m:mo>=</m:mo>
                <m:munderover>
<m:mrow>
                  <m:mo>∑</m:mo>
</m:mrow>        
          <m:mrow>
                    <m:mi>m</m:mi>
                    <m:mo>=</m:mo>
                    <m:mn>0</m:mn>
                  </m:mrow>
                  <m:mrow>
                    <m:mi>M</m:mi>
                    <m:mo>-</m:mo>
                    <m:mn>1</m:mn>
                  </m:mrow>
                </m:munderover>
                <m:mo>〈</m:mo>
                <m:msup>
                  <m:mi>R</m:mi>
                  <m:mrow>
                    <m:mspace width="0.166667em"/>
                    <m:mi>m</m:mi>
                  </m:mrow>
                </m:msup>
                <m:mspace width="0.166667em"/>
                <m:mi>f</m:mi>
                <m:mo>,</m:mo>
                <m:msub>
                  <m:mi>φ</m:mi>
                  <m:msub>
                    <m:mi>p</m:mi>
                    <m:mi>m</m:mi>
                  </m:msub>
                </m:msub>
                <m:mo>〉</m:mo>
                <m:mspace width="0.166667em"/>
                <m:msub>
                  <m:mi>φ</m:mi>
                  <m:msub>
                    <m:mi>p</m:mi>
                    <m:mi>m</m:mi>
                  </m:msub>
                </m:msub>
                <m:mo>+</m:mo>
                <m:msup>
                  <m:mi>R</m:mi>
                  <m:mrow>
                    <m:mspace width="0.166667em"/>
                    <m:mi>M</m:mi>
                  </m:mrow>
                </m:msup>
                <m:mspace width="0.166667em"/>
                <m:mi>f</m:mi>
                <m:mo>.</m:mo>
              </m:mrow>
            </m:math>
          </equation>
          <para id="id2261430">The approximation from the <emphasis effect="italics">M</emphasis>-selected
vectors <m:math overflow="scroll"><m:msub><m:mrow><m:mo>{</m:mo><m:msub><m:mi>φ</m:mi><m:msub><m:mi>p</m:mi><m:mi>m</m:mi></m:msub></m:msub><m:mo>}</m:mo></m:mrow><m:mrow><m:mn>0</m:mn><m:mo>≤</m:mo><m:mi>m</m:mi><m:mo>&lt;</m:mo><m:mi>M</m:mi></m:mrow></m:msub></m:math>
can be refined with an orthogonal back projection on the space
generated by these vectors.
An orthogonal matching pursuit further improves this decomposition
by orthogonalizing progressively the projection directions <m:math overflow="scroll"><m:msub><m:mi>φ</m:mi><m:msub><m:mi>p</m:mi><m:mi>m</m:mi></m:msub></m:msub></m:math>
during the decompositon.
The resulting decompositions are applied to compression,
denoising, and pattern recognition of various types of signals, images,
and videos.</para>
        </section>
        <section id="uid17">
          <title>Basis Pursuit</title>
          <para id="id2261528">Approximating <m:math overflow="scroll"><m:mrow><m:mspace width="0.166667em"/><m:mi>f</m:mi></m:mrow></m:math> with a minimum number of
nonzero coefficients <m:math overflow="scroll"><m:mrow><m:mi>a</m:mi><m:mo>[</m:mo><m:mspace width="0.166667em"/><m:mi>p</m:mi><m:mo>]</m:mo></m:mrow></m:math> in a dictionary <m:math overflow="scroll"><m:mi mathvariant="script">D</m:mi></m:math>
is equivalent to minimizing the <m:math overflow="scroll"><m:msup><m:mn>1</m:mn><m:mn>0</m:mn></m:msup></m:math> norm <m:math overflow="scroll"><m:msub><m:mrow><m:mo>∥</m:mo><m:mi>a</m:mi><m:mo>∥</m:mo></m:mrow><m:mn>0</m:mn></m:msub></m:math>, which gives
the number of nonzero coefficients.
This <m:math overflow="scroll"><m:msup><m:mn>1</m:mn><m:mn>0</m:mn></m:msup></m:math> norm is highly nonconvex, which explains why the
resulting minimization is NP-hard.
Donoho and Chen (DonohoC:95) thus proposed
replacing the <m:math overflow="scroll"><m:msup><m:mn>1</m:mn><m:mn>0</m:mn></m:msup></m:math> norm by the <m:math overflow="scroll"><m:msup><m:mn>1</m:mn><m:mn>1</m:mn></m:msup></m:math> norm
<m:math overflow="scroll"><m:mrow><m:msub><m:mrow><m:mo>∥</m:mo><m:mi>a</m:mi><m:mo>∥</m:mo></m:mrow><m:mn>1</m:mn></m:msub><m:mo>=</m:mo><m:msub><m:mo>∑</m:mo><m:mrow><m:mi>p</m:mi><m:mo>∈</m:mo><m:mi>γ</m:mi></m:mrow></m:msub><m:mrow><m:mo>|</m:mo><m:mi>a</m:mi><m:mrow><m:mo>[</m:mo><m:mspace width="0.166667em"/><m:mi>p</m:mi><m:mo>]</m:mo></m:mrow><m:mo>|</m:mo></m:mrow></m:mrow></m:math>, which is convex.
The resulting
basis pursuit algorithm computes a synthesis operator</para>
          <equation id="uid19">
            <m:math overflow="scroll" mode="display">
              <m:mtable displaystyle="true">
                <m:mtr>
                  <m:mtd columnalign="right">
                    <m:mrow>
                      <m:mi>f</m:mi>
                      <m:mo>=</m:mo>
                      <m:munder>
                        <m:mo>∑</m:mo>
                        <m:mrow>
                          <m:mi>p</m:mi>
                          <m:mo>∈</m:mo>
                          <m:mi>γ</m:mi>
                        </m:mrow>
                      </m:munder>
                      <m:mi>a</m:mi>
                      <m:mrow>
                        <m:mo>[</m:mo>
                        <m:mspace width="0.166667em"/>
                        <m:mi>p</m:mi>
                        <m:mo>]</m:mo>
                      </m:mrow>
                      <m:mspace width="0.166667em"/>
                      <m:msub>
                        <m:mi>φ</m:mi>
                        <m:mi>p</m:mi>
                      </m:msub>
                      <m:msub>
                        <m:mrow>
                          <m:mo>,</m:mo>
                          <m:mspace width="3.33333pt"/>
                          <m:mspace width="3.33333pt"/>
                          <m:mtext>which</m:mtext>
                          <m:mspace width="4.pt"/>
                          <m:mtext>minimizes</m:mtext>
                          <m:mspace width="3.33333pt"/>
                          <m:mspace width="3.33333pt"/>
                          <m:mo>∥</m:mo>
                          <m:mi>a</m:mi>
                          <m:mo>∥</m:mo>
                        </m:mrow>
                        <m:mn>1</m:mn>
                      </m:msub>
                      <m:mo>=</m:mo>
                      <m:munder>
                        <m:mo>∑</m:mo>
                        <m:mrow>
                          <m:mi>p</m:mi>
                          <m:mo>∈</m:mo>
                          <m:mi>γ</m:mi>
                        </m:mrow>
                      </m:munder>
                      <m:mrow>
                        <m:mo>|</m:mo>
                        <m:mi>a</m:mi>
                        <m:mrow>
                          <m:mo>[</m:mo>
                          <m:mspace width="0.166667em"/>
                          <m:mi>p</m:mi>
                          <m:mo>]</m:mo>
                        </m:mrow>
                        <m:mo>|</m:mo>
                      </m:mrow>
                      <m:mo>.</m:mo>
                    </m:mrow>
                  </m:mtd>
                </m:mtr>
              </m:mtable>
            </m:math>
          </equation>
          <para id="id2261853">This optimal solution
is calculated with a linear programming algorithm.
A basis pursuit is computationally more intense than a
matching pursuit, but it is a more global optimization
that yields representations that can be moresparse.</para>
          <para id="id2261860">In approximation, compression, or denoising applications,
<m:math overflow="scroll"><m:mrow><m:mspace width="0.166667em"/><m:mi>f</m:mi></m:mrow></m:math> is recovered with an error bounded by a precision parameter
<emphasis effect="italics">ϵ</emphasis>. The optimization <link target-id="uid20"/> is thus relaxed
by finding a synthesis such that</para>
          <equation id="uid20">
            <m:math overflow="scroll" mode="display">
              <m:mtable displaystyle="true">
                <m:mtr>
                  <m:mtd columnalign="right">
                    <m:mrow>
                      <m:mrow>
                        <m:mo>∥</m:mo>
                        <m:mspace width="0.166667em"/>
                        <m:mi>f</m:mi>
                        <m:mo>-</m:mo>
                      </m:mrow>
                      <m:munder>
                        <m:mo>∑</m:mo>
                        <m:mrow>
                          <m:mi>p</m:mi>
                          <m:mo>∈</m:mo>
                          <m:mi>γ</m:mi>
                        </m:mrow>
                      </m:munder>
                      <m:mi>a</m:mi>
                      <m:mrow>
                        <m:mo>[</m:mo>
                        <m:mspace width="0.166667em"/>
                        <m:mi>p</m:mi>
                        <m:mo>]</m:mo>
                      </m:mrow>
                      <m:mspace width="0.166667em"/>
                      <m:msub>
                        <m:mi>φ</m:mi>
                        <m:mi>p</m:mi>
                      </m:msub>
                      <m:msub>
                        <m:mrow>
                          <m:mo>∥</m:mo>
                          <m:mo>≤</m:mo>
                          <m:mi>ϵ</m:mi>
                          <m:mo>,</m:mo>
                          <m:mspace width="3.33333pt"/>
                          <m:mspace width="3.33333pt"/>
                          <m:mtext>which</m:mtext>
                          <m:mspace width="4.pt"/>
                          <m:mtext>minimizes</m:mtext>
                          <m:mspace width="3.33333pt"/>
                          <m:mspace width="3.33333pt"/>
                          <m:mo>∥</m:mo>
                          <m:mi>a</m:mi>
                          <m:mo>∥</m:mo>
                        </m:mrow>
                        <m:mn>1</m:mn>
                      </m:msub>
                      <m:mo>=</m:mo>
                      <m:munder>
                        <m:mo>∑</m:mo>
                        <m:mrow>
                          <m:mi>p</m:mi>
                          <m:mo>∈</m:mo>
                          <m:mi>γ</m:mi>
                        </m:mrow>
                      </m:munder>
                      <m:mrow>
                        <m:mo>|</m:mo>
                        <m:mi>a</m:mi>
                        <m:mrow>
                          <m:mo>[</m:mo>
                          <m:mspace width="0.166667em"/>
                          <m:mi>p</m:mi>
                          <m:mo>]</m:mo>
                        </m:mrow>
                        <m:mo>|</m:mo>
                      </m:mrow>
                      <m:mo>.</m:mo>
                    </m:mrow>
                  </m:mtd>
                </m:mtr>
              </m:mtable>
            </m:math>
          </equation>
          <para id="id2262045">
This is a convex minimization problem, with a
solution calculated by minimizing the corresponding <m:math overflow="scroll"><m:msup><m:mn>1</m:mn><m:mn>1</m:mn></m:msup></m:math> Lagrangian</para>
          <equation id="id2262074">
            <m:math overflow="scroll" mode="display">
              <m:mrow>
                <m:msub>
                  <m:mi mathvariant="script">L</m:mi>
                  <m:mn>1</m:mn>
                </m:msub>
                <m:mrow>
                  <m:mrow>
                    <m:mo>(</m:mo>
                    <m:mi>T</m:mi>
                    <m:mo>,</m:mo>
                    <m:mi>f</m:mi>
                    <m:mo>,</m:mo>
                    <m:mi>a</m:mi>
                    <m:mo>)</m:mo>
                  </m:mrow>
                  <m:mo>=</m:mo>
                  <m:mo>∥</m:mo>
                  <m:mspace width="0.166667em"/>
                  <m:mi>f</m:mi>
                  <m:mo>-</m:mo>
                </m:mrow>
                <m:munder>
                  <m:mo>∑</m:mo>
                  <m:mrow>
                    <m:mi>p</m:mi>
                    <m:mo>∈</m:mo>
                    <m:mi>γ</m:mi>
                  </m:mrow>
                </m:munder>
                <m:mi>a</m:mi>
                <m:mrow>
                  <m:mo>[</m:mo>
                  <m:mspace width="0.166667em"/>
                  <m:mi>p</m:mi>
                  <m:mo>]</m:mo>
                </m:mrow>
                <m:mspace width="0.166667em"/>
                <m:msub>
                  <m:mi>φ</m:mi>
                  <m:mi>p</m:mi>
                </m:msub>
                <m:msup>
                  <m:mrow>
                    <m:mo>∥</m:mo>
                  </m:mrow>
                  <m:mn>2</m:mn>
                </m:msup>
                <m:mo>+</m:mo>
                <m:mi>T</m:mi>
                <m:mspace width="0.166667em"/>
                <m:msub>
                  <m:mrow>
                    <m:mo>∥</m:mo>
                    <m:mi>a</m:mi>
                    <m:mo>∥</m:mo>
                  </m:mrow>
                  <m:mn>1</m:mn>
                </m:msub>
                <m:mo>,</m:mo>
              </m:mrow>
            </m:math>
          </equation>
          <para id="id2262192">where <emphasis effect="italics">T</emphasis> is a Lagrange multiplier that depends on <emphasis effect="italics">ϵ</emphasis>.
This is called an <m:math overflow="scroll"><m:msup><m:mn>1</m:mn><m:mn>1</m:mn></m:msup></m:math> Lagrangian pursuit in this book.
A solution <m:math overflow="scroll"><m:mrow><m:mover accent="true"><m:mi>a</m:mi><m:mo>˜</m:mo></m:mover><m:mrow><m:mo>[</m:mo><m:mspace width="0.166667em"/><m:mi>p</m:mi><m:mo>]</m:mo></m:mrow></m:mrow></m:math> is computed with iterative
algorithms that are guaranteed to converge.
The number of nonzero coordinates of
<m:math overflow="scroll"><m:mover accent="true"><m:mi>a</m:mi><m:mo>˜</m:mo></m:mover></m:math> typically decrea-ses as <emphasis effect="italics">T</emphasis> increases.</para>
        </section>
        <section id="uid22">
          <title>Incoherence for Support Recovery</title>
          <para id="id2262303">Matching pursuit and <m:math overflow="scroll"><m:msup><m:mn>1</m:mn><m:mn>1</m:mn></m:msup></m:math> Lagrangian pursuits are optimal if
they recover the approx-imation support <emphasis effect="italics">λ<sub>T</sub></emphasis>, which minimizes
the approximation Lagrangian</para>
          <equation id="id2262338">
            <m:math overflow="scroll" mode="display">
              <m:mrow>
                <m:msub>
                  <m:mi mathvariant="script">L</m:mi>
                  <m:mn>0</m:mn>
                </m:msub>
                <m:mrow>
                  <m:mrow>
                    <m:mo>(</m:mo>
                    <m:mi>T</m:mi>
                    <m:mo>,</m:mo>
                    <m:mi>f</m:mi>
                    <m:mo>,</m:mo>
                    <m:mi>λ</m:mi>
                    <m:mo>)</m:mo>
                  </m:mrow>
                  <m:mo>=</m:mo>
                  <m:mo>∥</m:mo>
                  <m:mspace width="0.166667em"/>
                  <m:mi>f</m:mi>
                  <m:mo>-</m:mo>
                </m:mrow>
                <m:msub>
                  <m:mi>f</m:mi>
                  <m:mi>λ</m:mi>
                </m:msub>
                <m:msup>
                  <m:mrow>
                    <m:mo>∥</m:mo>
                  </m:mrow>
                  <m:mn>2</m:mn>
                </m:msup>
                <m:mo>+</m:mo>
                <m:msup>
                  <m:mi>T</m:mi>
                  <m:mn>2</m:mn>
                </m:msup>
                <m:mspace width="0.166667em"/>
                <m:mrow>
                  <m:mo>|</m:mo>
                  <m:mi>λ</m:mi>
                  <m:mo>|</m:mo>
                </m:mrow>
                <m:mo>,</m:mo>
              </m:mrow>
            </m:math>
          </equation>
          <para id="id2262426">where <m:math overflow="scroll"><m:mrow><m:mspace width="0.166667em"/><m:msub><m:mi>f</m:mi><m:mi>λ</m:mi></m:msub></m:mrow></m:math> is the orthogonal projection of <m:math overflow="scroll"><m:mrow><m:mspace width="0.166667em"/><m:mi>f</m:mi></m:mrow></m:math> in the
space <emphasis effect="italics">V<sub>λ</sub></emphasis> generated by <m:math overflow="scroll"><m:msub><m:mrow><m:mo>{</m:mo><m:msub><m:mi>φ</m:mi><m:mi>p</m:mi></m:msub><m:mo>}</m:mo></m:mrow><m:mrow><m:mi>p</m:mi><m:mo>∈</m:mo><m:mi>Λ</m:mi></m:mrow></m:msub></m:math>.
This is not always true and depends on <emphasis effect="italics">λ<sub>T</sub></emphasis>.
An <emphasis effect="italics">Exact Recovery Criteria</emphasis>
proved byTropp (tropp-multi-omp)
guarantees that pursuit algorithms do recover the optimal
support<emphasis effect="italics">λ<sub>T</sub></emphasis> if </para>
          <equation id="uid25">
            <m:math overflow="scroll" mode="display">
              <m:mtable displaystyle="true">
                <m:mtr>
                  <m:mtd columnalign="right">
                    <m:mrow>
                      <m:mi>E</m:mi>
                      <m:mi>R</m:mi>
                      <m:mi>C</m:mi>
                      <m:mrow>
                        <m:mo>(</m:mo>
                        <m:msub>
                          <m:mi>λ</m:mi>
                          <m:mi>T</m:mi>
                        </m:msub>
                        <m:mo>)</m:mo>
                      </m:mrow>
                      <m:mo>=</m:mo>
                      <m:munder>
                        <m:mo movablelimits="true" form="prefix">max</m:mo>
                        <m:mrow>
                          <m:mi>q</m:mi>
                          <m:mrow>
                            <m:mo>∈</m:mo>
                            <m:mspace width="-0.166667em"/>
                            <m:mspace width="-0.166667em"/>
                            <m:mspace width="-0.166667em"/>
                            <m:mo>/</m:mo>
                          </m:mrow>
                          <m:msub>
                            <m:mi>λ</m:mi>
                            <m:mi>T</m:mi>
                          </m:msub>
                        </m:mrow>
                      </m:munder>
                      <m:munder>
                        <m:mo>∑</m:mo>
                        <m:mrow>
                          <m:mi>p</m:mi>
                          <m:mo>∈</m:mo>
                          <m:msub>
                            <m:mi>λ</m:mi>
                            <m:mi>T</m:mi>
                          </m:msub>
                        </m:mrow>
                      </m:munder>
                      <m:mrow>
                        <m:mo>|</m:mo>
                        <m:mo>〈</m:mo>
                        <m:msub>
                          <m:mover accent="true">
                            <m:mi>φ</m:mi>
                            <m:mo>˜</m:mo>
                          </m:mover>
                          <m:mi>p</m:mi>
                        </m:msub>
                        <m:mo>,</m:mo>
                        <m:msub>
                          <m:mi>φ</m:mi>
                          <m:mi>q</m:mi>
                        </m:msub>
                        <m:mo>〉</m:mo>
                        <m:mo>|</m:mo>
                      </m:mrow>
                      <m:mo>&lt;</m:mo>
                      <m:mn>1</m:mn>
                      <m:mo>,</m:mo>
                    </m:mrow>
                  </m:mtd>
                </m:mtr>
              </m:mtable>
            </m:math>
          </equation>
<!--empty paragraphs get left behind.-->
          <para id="id2262701">where <m:math overflow="scroll"><m:msub><m:mrow><m:mo>{</m:mo><m:msub><m:mover accent="true"><m:mi>φ</m:mi><m:mo>˜</m:mo></m:mover><m:mi>p</m:mi></m:msub><m:mo>}</m:mo></m:mrow><m:mrow><m:mi>p</m:mi><m:mo>∈</m:mo><m:msub><m:mi>Λ</m:mi><m:mi>T</m:mi></m:msub></m:mrow></m:msub></m:math> is the biorthogonal basis of
<m:math overflow="scroll"><m:msub><m:mrow><m:mo>{</m:mo><m:msub><m:mi>φ</m:mi><m:mi>p</m:mi></m:msub><m:mo>}</m:mo></m:mrow><m:mrow><m:mi>p</m:mi><m:mo>∈</m:mo><m:msub><m:mi>Λ</m:mi><m:mi>T</m:mi></m:msub></m:mrow></m:msub></m:math> in <m:math overflow="scroll"><m:msub><m:mi mathvariant="bold">V</m:mi><m:msub><m:mi>Λ</m:mi><m:mi>T</m:mi></m:msub></m:msub></m:math>. This criterion implies that
dictionary vectors
<emphasis effect="italics">φ<sub>q</sub></emphasis> outside <emphasis effect="italics">λ<sub>T</sub></emphasis> should have a small inner product with
vectors in <emphasis effect="italics">λ<sub>T</sub></emphasis>.</para>
          <para id="id2262856">This recovery is stable relative to noise perturbations if
<m:math overflow="scroll"><m:msub><m:mrow><m:mo>{</m:mo><m:msub><m:mi>φ</m:mi><m:mi>p</m:mi></m:msub><m:mo>}</m:mo></m:mrow><m:mrow><m:mi>p</m:mi><m:mo>∈</m:mo><m:mi>Λ</m:mi></m:mrow></m:msub></m:math> has Riesz bounds that are not too far from 1.
These vectors should be nearly orthogonal and hence have
small inner products. These small inner-product conditions are
interpreted as a form of incoherence.
A stable recovery of <emphasis effect="italics">λ<sub>T</sub></emphasis> is possible if vectors in <emphasis effect="italics">λ<sub>T</sub></emphasis> are
incoherent with respect to other dictionary vectors and are incoherent
between themselves. It depends on the geometric
configuration of <emphasis effect="italics">λ<sub>T</sub></emphasis> in <emphasis effect="italics">γ</emphasis>.</para>
<!--empty paragraphs get left behind.-->
        </section>
      </section>
   
    
  </content>
</document>